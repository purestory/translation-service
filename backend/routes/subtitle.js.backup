const express = require('express');
const multer = require('multer');
const path = require('path');
const fs = require('fs');
const router = express.Router();
const TranslationService = require('../services/translationService');
const SubtitleParser = require('../utils/subtitleParser');

const translationService = new TranslationService();

// Multer ì„¤ì •
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    const uploadPath = path.join(__dirname, '../uploads');
    if (!fs.existsSync(uploadPath)) {
      fs.mkdirSync(uploadPath, { recursive: true });
    }
    cb(null, uploadPath);
  },
  filename: (req, file, cb) => {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    cb(null, file.fieldname + '-' + uniqueSuffix + path.extname(file.originalname));
  }
});

const fileFilter = (req, file, cb) => {
  const allowedTypes = ['.srt', '.smi', '.vtt', '.ass'];
  const fileExt = path.extname(file.originalname).toLowerCase();
  
  if (allowedTypes.includes(fileExt)) {
    cb(null, true);
  } else {
    cb(new Error('ì§€ì›í•˜ì§€ ì•ŠëŠ” íŒŒì¼ í˜•ì‹ì…ë‹ˆë‹¤. SRT, SMI, VTT íŒŒì¼ë§Œ ì—…ë¡œë“œ ê°€ëŠ¥í•©ë‹ˆë‹¤.'), false);
  }
};

const upload = multer({ 
  storage: storage,
  limits: {
    fileSize: 10 * 1024 * 1024 // 10MB
  },
  fileFilter: fileFilter
});

// ìë§‰ íŒŒì¼ ì—…ë¡œë“œ ë° ë¶„ì„
router.post('/upload', upload.single('subtitle'), async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({
        success: false,
        error: 'íŒŒì¼ì´ ì—…ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.'
      });
    }

    console.log(`ìë§‰ íŒŒì¼ ì—…ë¡œë“œ: ${req.file.originalname} (${req.file.size} bytes)`);

    // ì›ë³¸ íŒŒì¼ëª… ì •ë³´ë¥¼ ë©”íƒ€ íŒŒì¼ë¡œ ì €ì¥
    const metaPath = path.join(__dirname, '../uploads', req.file.filename + '.meta');
    const metaData = {
      originalName: req.file.originalname,
      uploadTime: new Date().toISOString(),
      fileSize: req.file.size,
      mimeType: req.file.mimetype
    };
    fs.writeFileSync(metaPath, JSON.stringify(metaData), 'utf8');

    // íŒŒì¼ íŒŒì‹±
    const parsed = SubtitleParser.parseSubtitle(req.file.path);
    const stats = SubtitleParser.getSubtitleStats(parsed.entries);

    // íŒŒì¼ ì •ë³´ ì‘ë‹µ
    res.json({
      success: true,
      data: {
        fileId: req.file.filename,
        originalName: req.file.originalname,
        format: parsed.format,
        stats: stats,
        preview: parsed.entries.slice(0, 3), // ì²˜ìŒ 3ê°œ ì—”íŠ¸ë¦¬ ë¯¸ë¦¬ë³´ê¸°
        uploadTime: new Date().toISOString()
      }
    });

  } catch (error) {
    console.error('íŒŒì¼ ì—…ë¡œë“œ ì˜¤ë¥˜:', error);
    
    // ì—…ë¡œë“œëœ íŒŒì¼ ì‚­ì œ
    if (req.file && fs.existsSync(req.file.path)) {
      fs.unlinkSync(req.file.path);
    }

    res.status(500).json({
      success: false,
      error: error.message || 'íŒŒì¼ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.'
    });
  }
});

// ì§„í–‰ ìƒíƒœë¥¼ ì €ì¥í•  ì „ì—­ ê°ì²´
const translationProgress = {};

// ì§„í–‰ ìƒíƒœ ì¡°íšŒ ì—”ë“œí¬ì¸íŠ¸ ì¶”ê°€
router.get('/progress/:fileId', (req, res) => {
  const fileId = req.params.fileId;
  const progress = translationProgress[fileId];
  
  if (!progress) {
    return res.status(404).json({
      success: false,
      error: 'ì§„í–‰ ì¤‘ì¸ ë²ˆì—­ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.'
    });
  }
  
  res.json({
    success: true,
    data: progress
  });
});

// ëŒ€ì²´ ë²ˆì—­ ì—”ì§„ ì‹œë„ í•¨ìˆ˜
async function tryFallbackTranslation(text, targetLang, sourceLang, currentEngine) {
  // ì‚¬ìš© ê°€ëŠ¥í•œ ì—”ì§„ ëª©ë¡ (Groqê³¼ Geminië§Œ ì‚¬ìš©)
  const engines = ['groq', 'gemini'];
  const fallbackEngines = engines.filter(engine => engine !== currentEngine);
  
  console.log(`\nğŸ›¡ï¸ ëŒ€ì²´ ë²ˆì—­ ì‹œë„:`);
  console.log(`   âŒ ì‹¤íŒ¨ ì—”ì§„: ${currentEngine}`);
  console.log(`   ğŸ”„ ì‹œë„í•  ì—”ì§„ë“¤: [${fallbackEngines.join(', ')}]`);
  console.log(`   ğŸ“ ë²ˆì—­í•  í…ìŠ¤íŠ¸: "${text.substring(0, 50)}${text.length > 50 ? '...' : ''}"`);
  console.log(`   ğŸ¯ ë²ˆì—­ ë°©í–¥: ${sourceLang || 'auto'} â†’ ${targetLang}`);
  
  for (let i = 0; i < fallbackEngines.length; i++) {
    const fallbackEngine = fallbackEngines[i];
    console.log(`\n   ğŸ¤– [${i+1}/${fallbackEngines.length}] ${fallbackEngine} ì—”ì§„ ì‹œë„ ì¤‘...`);
    
    try {
      const startTime = Date.now();
      const result = await translationService.translate(
        text,
        targetLang,
        sourceLang,
        fallbackEngine
      );
      const duration = Date.now() - startTime;
      
      if (result && result.translatedText && result.translatedText.trim()) {
        console.log(`   âœ… ${fallbackEngine} ì—”ì§„ ëŒ€ì²´ ë²ˆì—­ ì„±ê³µ! (${duration}ms)`);
        console.log(`   ğŸ“¤ ë²ˆì—­ ê²°ê³¼: "${result.translatedText.substring(0, 100)}${result.translatedText.length > 100 ? '...' : ''}"`);
        console.log(`   ğŸ“Š ì›ë³¸: ${text.length}ì â†’ ë²ˆì—­: ${result.translatedText.length}ì`);
        return result.translatedText;
      } else {
        console.warn(`   âš ï¸ ${fallbackEngine} ì—”ì§„ ì‘ë‹µ ì—†ìŒ ë˜ëŠ” ë¹„ì–´ìˆìŒ`);
      }
    } catch (error) {
      console.error(`   âŒ ${fallbackEngine} ì—”ì§„ ëŒ€ì²´ ë²ˆì—­ ì‹¤íŒ¨: ${error.message}`);
      if (error.stack) {
        console.error(`   ğŸ“ ìŠ¤íƒ íŠ¸ë ˆì´ìŠ¤: ${error.stack.split('\n')[1]}`);
      }
      continue;
    }
  }
  
  // ëª¨ë“  ì—”ì§„ì´ ì‹¤íŒ¨í•œ ê²½ìš°
  console.error(`\nğŸ’¥ ëª¨ë“  ëŒ€ì²´ ì—”ì§„ ì‹¤íŒ¨!`);
  console.error(`   ğŸ“ í…ìŠ¤íŠ¸: "${text.substring(0, 50)}${text.length > 50 ? '...' : ''}"`);
  console.error(`   ğŸ¯ ë²ˆì—­ ë°©í–¥: ${sourceLang || 'auto'} â†’ ${targetLang}`);
  console.error(`   ğŸ¤– ì‹œë„í•œ ì—”ì§„ë“¤: [${fallbackEngines.join(', ')}]`);
  
  return `[ë²ˆì—­ì‹¤íŒ¨] ${text}`;
}

// ìë§‰ íŒŒì¼ ë²ˆì—­
router.post('/translate', async (req, res) => {
  try {
    const { 
      fileId, 
      targetLang, 
      sourceLang, 
      engine = 'gemini', 
      outputFormat,
      chunkSize = 50,              // ì²­í¬ í¬ê¸° (ê¸°ë³¸ê°’: 50)
      translationMode = 'auto',    // ë²ˆì—­ ë°©ì‹: 'srt_direct', 'separator', 'auto'
      maxRetries = 5,              // ìµœëŒ€ ì¬ì‹œë„ íšŸìˆ˜
      retryDelay = 1000,           // ì¬ì‹œë„ ê°„ê²© (ms)
      enableFallback = true        // ëŒ€ì²´ ì—”ì§„ ì‚¬ìš© ì—¬ë¶€
    } = req.body;

    // ğŸ“‹ ìƒì„¸ ìš”ì²­ ë¡œê·¸
    console.log('\n='.repeat(80));
    console.log('ğŸ¯ ë²ˆì—­ ìš”ì²­ ì‹œì‘');
    console.log('='.repeat(80));
    console.log(`ğŸ“‚ íŒŒì¼ ID: ${fileId}`);
    console.log(`ğŸŒ ì›ë³¸ ì–¸ì–´: ${sourceLang || 'auto'}`);
    console.log(`ğŸ¯ ëª©í‘œ ì–¸ì–´: ${targetLang}`);
    console.log(`ğŸ¤– ë²ˆì—­ ì—”ì§„: ${engine}`);
    console.log(`ğŸ“„ ì¶œë ¥ í˜•ì‹: ${outputFormat || 'auto'}`);
    console.log(`ğŸ“¦ ì²­í¬ í¬ê¸°: ${chunkSize}`);
    console.log(`âš™ï¸ ë²ˆì—­ ëª¨ë“œ: ${translationMode}`);
    console.log(`ğŸ”„ ìµœëŒ€ ì¬ì‹œë„: ${maxRetries}`);
    console.log(`â±ï¸ ì¬ì‹œë„ ê°„ê²©: ${retryDelay}ms`);
    console.log(`ğŸ›¡ï¸ ëŒ€ì²´ ì—”ì§„: ${enableFallback ? 'í™œì„±í™”' : 'ë¹„í™œì„±í™”'}`);
    console.log(`â° ìš”ì²­ ì‹œê°„: ${new Date().toISOString()}`);
    console.log('='.repeat(80));

    if (!fileId || !targetLang) {
      return res.status(400).json({
        success: false,
        error: 'í•„ìˆ˜ ë§¤ê°œë³€ìˆ˜ê°€ ëˆ„ë½ë˜ì—ˆìŠµë‹ˆë‹¤.',
        required: ['fileId', 'targetLang'],
        optional: {
          chunkSize: 'ì²­í¬ í¬ê¸° (ê¸°ë³¸ê°’: 50)',
          translationMode: 'ë²ˆì—­ ë°©ì‹ - auto(ìë™), srt_direct(SRTì§ì ‘), separator(êµ¬ë¶„ì)',
          maxRetries: 'ìµœëŒ€ ì¬ì‹œë„ íšŸìˆ˜ (ê¸°ë³¸ê°’: 5)',
          retryDelay: 'ì¬ì‹œë„ ê°„ê²© ë°€ë¦¬ì´ˆ (ê¸°ë³¸ê°’: 1000)',
          enableFallback: 'ëŒ€ì²´ ì—”ì§„ ì‚¬ìš© ì—¬ë¶€ (ê¸°ë³¸ê°’: true)'
        }
      });
    }

    // ğŸ§¹ ê¸°ì¡´ ë²ˆì—­ íŒŒì¼ë“¤ ì‚­ì œ
    console.log('\nğŸ§¹ ê¸°ì¡´ ë²ˆì—­ íŒŒì¼ ì •ë¦¬ ì‹œì‘...');
    const uploadsDir = path.join(__dirname, '../uploads');
    const files = fs.readdirSync(uploadsDir);
    let deletedCount = 0;
    
    files.forEach(file => {
      if (file.includes('_translated_') && (file.endsWith('.srt') || file.endsWith('.vtt') || file.endsWith('.ass') || file.endsWith('.meta'))) {
        try {
          fs.unlinkSync(path.join(uploadsDir, file));
          deletedCount++;
          console.log(`   âŒ ì‚­ì œ: ${file}`);
        } catch (error) {
          console.warn(`   âš ï¸ ì‚­ì œ ì‹¤íŒ¨: ${file} - ${error.message}`);
        }
      }
    });
    console.log(`âœ… ê¸°ì¡´ ë²ˆì—­ íŒŒì¼ ${deletedCount}ê°œ ì‚­ì œ ì™„ë£Œ\n`);

    // ì˜µì…˜ ê²€ì¦
    const validatedChunkSize = Math.max(1, Math.min(parseInt(chunkSize) || 50, 1000)); // 1-1000 ë²”ìœ„
    const validatedMaxRetries = Math.max(1, Math.min(parseInt(maxRetries) || 5, 10)); // 1-10 ë²”ìœ„
    const validatedRetryDelay = Math.max(100, Math.min(parseInt(retryDelay) || 1000, 10000)); // 100ms-10s ë²”ìœ„
    const validTranslationModes = ['auto', 'srt_direct', 'separator'];
    const validatedTranslationMode = validTranslationModes.includes(translationMode) ? translationMode : 'auto';

    console.log(`ğŸ”§ ê²€ì¦ëœ ë²ˆì—­ ì˜µì…˜:`);
    console.log(`   ğŸ“¦ ì²­í¬ í¬ê¸°: ${validatedChunkSize}ê°œ (ìš”ì²­: ${chunkSize})`);
    console.log(`   âš™ï¸ ë²ˆì—­ ë°©ì‹: ${validatedTranslationMode} (ìš”ì²­: ${translationMode})`);
    console.log(`   ğŸ”„ ìµœëŒ€ ì¬ì‹œë„: ${validatedMaxRetries}íšŒ (ìš”ì²­: ${maxRetries})`);
    console.log(`   â±ï¸ ì¬ì‹œë„ ê°„ê²©: ${validatedRetryDelay}ms (ìš”ì²­: ${retryDelay})`);
    console.log(`   ğŸ›¡ï¸ ëŒ€ì²´ ì—”ì§„: ${enableFallback ? 'í™œì„±í™”' : 'ë¹„í™œì„±í™”'}`);

    // ì—…ë¡œë“œëœ íŒŒì¼ ê²½ë¡œ
    const filePath = path.join(__dirname, '../uploads', fileId);
    
    if (!fs.existsSync(filePath)) {
      console.error(`âŒ íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ: ${filePath}`);
      return res.status(404).json({
        success: false,
        error: 'íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.'
      });
    }

    console.log(`âœ… ì›ë³¸ íŒŒì¼ í™•ì¸: ${filePath}`);

    // ì›ë³¸ íŒŒì¼ëª… ì •ë³´ íŒŒì¼ ê²½ë¡œ
    const metaPath = path.join(__dirname, '../uploads', fileId + '.meta');
    let originalName = fileId;
    
    // ë©”íƒ€ ì •ë³´ì—ì„œ ì›ë³¸ íŒŒì¼ëª… ì½ê¸°
    if (fs.existsSync(metaPath)) {
      try {
        const metaData = JSON.parse(fs.readFileSync(metaPath, 'utf8'));
        originalName = metaData.originalName || fileId;
        console.log(`ğŸ“‹ ë©”íƒ€ ì •ë³´ ë¡œë“œ: ${originalName}`);
      } catch (error) {
        console.warn(`âš ï¸ ë©”íƒ€ íŒŒì¼ ì½ê¸° ì˜¤ë¥˜: ${error.message}`);
      }
    } else {
      console.log(`ğŸ“‹ ë©”íƒ€ íŒŒì¼ ì—†ìŒ, íŒŒì¼ID ì‚¬ìš©: ${fileId}`);
    }

    console.log(`\nğŸ¬ ìë§‰ ë²ˆì—­ ì‹œì‘:`);
    console.log(`   ğŸ“ ì›ë³¸: ${originalName}`);
    console.log(`   ğŸ†” íŒŒì¼ID: ${fileId}`);
    console.log(`   ğŸ¯ ${sourceLang || 'auto'} â†’ ${targetLang}`);
    console.log(`   ğŸ¤– ì—”ì§„: ${engine}`);

    // íŒŒì¼ íŒŒì‹±
    console.log(`\nğŸ“– íŒŒì¼ íŒŒì‹± ì¤‘...`);
    const parsed = SubtitleParser.parseSubtitle(filePath);
    const entries = parsed.entries;
    
    console.log(`âœ… íŒŒì‹± ì™„ë£Œ:`);
    console.log(`   ğŸ“„ í˜•ì‹: ${parsed.format}`);
    console.log(`   ğŸ“ ìë§‰ ìˆ˜: ${entries.length}ê°œ`);

    if (entries.length === 0) {
      console.error(`âŒ ìë§‰ ì—”íŠ¸ë¦¬ê°€ ì—†ìŒ`);
      return res.status(400).json({
        success: false,
        error: 'ìë§‰ ì—”íŠ¸ë¦¬ê°€ ì—†ìŠµë‹ˆë‹¤.'
      });
    }

    // ì´ ê¸€ììˆ˜ ê³„ì‚°
    const totalCharacters = entries.reduce((sum, entry) => sum + entry.text.length, 0);
    const avgTextLength = totalCharacters / entries.length;
    
    console.log(`ğŸ“Š ìë§‰ í†µê³„:`);
    console.log(`   ğŸ’¬ ì´ ê¸€ììˆ˜: ${totalCharacters.toLocaleString()}ì`);
    console.log(`   ğŸ“ í‰ê·  ê¸¸ì´: ${Math.round(avgTextLength)}ì/ìë§‰`);
    console.log(`   â±ï¸ ì˜ˆìƒ ë²ˆì—­ì‹œê°„: ${Math.round(totalCharacters / 1000)}ì´ˆ (1000ì/ì´ˆ ê¸°ì¤€)`);

    // ì§„í–‰ ìƒíƒœ ì´ˆê¸°í™”
    translationProgress[fileId] = {
      status: 'processing',
      progress: 0,
      totalEntries: entries.length,
      processedEntries: 0,
      totalCharacters: totalCharacters,
      processedCharacters: 0,
      startTime: Date.now(),
      currentChunk: 0,
      totalChunks: 0,
      estimatedTimeRemaining: 0,
      averageCharsPerSecond: 0,
      message: 'ë²ˆì—­ ì¤€ë¹„ ì¤‘...'
    };

    // ìë§‰ì„ ì ì ˆí•œ í¬ê¸°ì˜ ì²­í¬ë¡œ ë¶„í•  (ì˜µì…˜ ê¸°ë°˜)
    const maxChunkSize = validatedChunkSize;
    
    console.log(`í‰ê·  í…ìŠ¤íŠ¸ ê¸¸ì´: ${Math.round(avgTextLength)}ì, ì—”ì§„: ${engine}, ì²­í¬ í¬ê¸°: ${maxChunkSize}ê°œ (ì˜µì…˜ ì„¤ì •)`);

    const totalChunks = Math.ceil(entries.length / maxChunkSize);
    translationProgress[fileId].totalChunks = totalChunks;
    translationProgress[fileId].message = `ì´ ${totalChunks}ê°œ ì²­í¬ë¡œ ë²ˆì—­ ì§„í–‰ (ì²­í¬ë‹¹ ${maxChunkSize}ê°œ, ë°©ì‹: ${validatedTranslationMode})`;

    console.log(`ë°°ì¹˜ ë²ˆì—­ ì„¤ì •: ì—”ì§„=${engine}, ì²­í¬í¬ê¸°=${maxChunkSize}, ì´ ìë§‰=${entries.length}ê°œ, ì´ ê¸€ììˆ˜=${totalCharacters}ì`);

    const translatedEntries = [];
    let totalProcessed = 0;
    let totalProcessedChars = 0;
    const startTime = Date.now();

    for (let i = 0; i < entries.length; i += maxChunkSize) {
      const currentChunkIndex = Math.floor(i / maxChunkSize) + 1;
      const totalChunks = Math.ceil(entries.length / maxChunkSize);
      const chunk = entries.slice(i, i + maxChunkSize);
      const chunkChars = chunk.reduce((sum, entry) => sum + entry.text.length, 0);
      
      // ë²ˆì—­ ìš”ì²­ ì „ ë¡œê¹…
      const chunkStartTime = Date.now();

      // ë²ˆì—­ ëª¨ë“œ ê²°ì • ë¡œì§
      let shouldUseSrtDirect = false;
      let shouldUseSeparator = false;
      
      // SRT í˜•ì‹ì´ê³  srt_direct ëª¨ë“œì¸ ê²½ìš°
      if (validatedTranslationMode === 'srt_direct' && (parsed.format === 'srt' || parsed.format === 'vtt')) {
        shouldUseSrtDirect = true;
      } else if (validatedTranslationMode === 'separator') {
        shouldUseSeparator = true;
      } else {
        // auto ëª¨ë“œ: ì¡°ê±´ì— ë”°ë¼ ìë™ ê²°ì •
        if (parsed.format === 'srt' && chunk.length <= 10) {
          shouldUseSrtDirect = true;
        } else {
          shouldUseSeparator = true;
        }
      }

      if (shouldUseSrtDirect) {
        // ğŸ¯ SRT ì²­í¬ ì§ì ‘ ë²ˆì—­
        const srtChunk = SubtitleParser.generateSubtitle(chunk, 'srt');
        console.log(`ğŸ†• SRT ì²­í¬ ${currentChunkIndex}/${totalChunks} ì§ì ‘ ë²ˆì—­ ì‹œì‘ (${chunk.length}ê°œ ìë§‰, ${srtChunk.length}ì)`);
        console.log(`SRT ì²­í¬ ë¯¸ë¦¬ë³´ê¸°: ${srtChunk.substring(0, 200)}...`);
      
      let result;
        let translatedTexts = [];
      let retryCount = 0;
      
        // ì¬ì‹œë„ ë¡œì§ìœ¼ë¡œ ì•ˆì •ì„± ê°•í™”
        while (retryCount <= validatedMaxRetries) {
          try {
            // SRT ì²­í¬ ì§ì ‘ ë²ˆì—­
            result = await translationService.translate(
              srtChunk, 
              targetLang, 
              sourceLang, 
              engine
            );
            
            console.log(`ì²­í¬ ${currentChunkIndex} ë²ˆì—­ ì‘ë‹µ ê¸¸ì´: ${result.translatedText.length}ì`);
            console.log(`ì²­í¬ ${currentChunkIndex} ë²ˆì—­ ì‘ë‹µ ë¯¸ë¦¬ë³´ê¸°: ${result.translatedText.substring(0, 300)}...`);
            
            // ë²ˆì—­ëœ SRTì—ì„œ í…ìŠ¤íŠ¸ë§Œ ì¶”ì¶œ
            const translatedSrtLines = result.translatedText.split('\n');
            translatedTexts = [];
            
            for (let lineIndex = 0; lineIndex < translatedSrtLines.length; lineIndex++) {
              const line = translatedSrtLines[lineIndex].trim();
              
              // ìˆ«ì ë¼ì¸ì´ë©´ ë‹¤ìŒì´ íƒ€ì„ìŠ¤íƒ¬í”„, ê·¸ ë‹¤ìŒì´ í…ìŠ¤íŠ¸
              if (/^\d+$/.test(line)) {
                // íƒ€ì„ìŠ¤íƒ¬í”„ ë¼ì¸ ê±´ë„ˆë›°ê¸°
                lineIndex++;
                if (lineIndex < translatedSrtLines.length && translatedSrtLines[lineIndex].includes('-->')) {
                  lineIndex++;
                  // í…ìŠ¤íŠ¸ ë¼ì¸(ë“¤) ìˆ˜ì§‘
                  let textLines = [];
                  while (lineIndex < translatedSrtLines.length && 
                         translatedSrtLines[lineIndex].trim() !== '' && 
                         !/^\d+$/.test(translatedSrtLines[lineIndex].trim())) {
                    textLines.push(translatedSrtLines[lineIndex].trim());
                    lineIndex++;
                  }
                  if (textLines.length > 0) {
                    translatedTexts.push(textLines.join('\n'));
                  }
                  lineIndex--; // for ë£¨í”„ì—ì„œ ì¦ê°€í•˜ë¯€ë¡œ í•˜ë‚˜ ë¹¼ê¸°
                }
              }
            }
            
            // ì¶”ì¶œëœ í…ìŠ¤íŠ¸ ê°œìˆ˜ í™•ì¸
            if (translatedTexts.length === chunk.length) {
              console.log(`âœ… SRT ì²­í¬ ${currentChunkIndex} ì§ì ‘ ë²ˆì—­ ì„±ê³µ: ${translatedTexts.length}ê°œ í…ìŠ¤íŠ¸ ì¶”ì¶œ`);
              break; // ì„±ê³µí•˜ë©´ ë£¨í”„ íƒˆì¶œ
            } else {
              throw new Error(`í…ìŠ¤íŠ¸ ê°œìˆ˜ ë¶ˆì¼ì¹˜: ì˜ˆìƒ=${chunk.length}, ì‹¤ì œ=${translatedTexts.length}`);
            }
            
          } catch (translateError) {
            retryCount++;
            console.error(`ì²­í¬ ${currentChunkIndex} ë²ˆì—­ ì˜¤ë¥˜ (ì‹œë„ ${retryCount}/${validatedMaxRetries + 1}):`, translateError);
            
            if (retryCount <= validatedMaxRetries) {
              console.log(`ì²­í¬ ${currentChunkIndex} ì¬ì‹œë„ ì¤‘... (${retryCount}/${validatedMaxRetries})`);
              await new Promise(resolve => setTimeout(resolve, validatedRetryDelay));
            } else {
              // ìµœëŒ€ ì¬ì‹œë„ ì´ˆê³¼ ì‹œ êµ¬ë¶„ì ë°©ì‹ìœ¼ë¡œ ëŒ€ì²´ ë˜ëŠ” ê°œë³„ ë²ˆì—­
              console.warn(`ì²­í¬ ${currentChunkIndex}: ìµœëŒ€ ì¬ì‹œë„ ì´ˆê³¼, êµ¬ë¶„ì ë°©ì‹ìœ¼ë¡œ ëŒ€ì²´`);
              shouldUseSeparator = true;
              break;
            }
          }
        }
      }
      
      if (shouldUseSeparator || !shouldUseSrtDirect) {
        // ğŸ”„ êµ¬ë¶„ì ë°©ì‹ ë²ˆì—­
        const texts = chunk.map(entry => entry.text);
        const combinedText = texts.join('\n---SUBTITLE_SEPARATOR---\n');
        
        console.log(`ğŸ”„ êµ¬ë¶„ì ì²­í¬ ${currentChunkIndex}/${totalChunks} ë²ˆì—­ ì‹œì‘ (${chunk.length}ê°œ ìë§‰, ${combinedText.length}ì)`);
        
        let result;
        let translatedTexts = [];
        let retryCount = 0;
        
        while (retryCount <= validatedMaxRetries) {
        try {
          result = await translationService.translate(
            combinedText, 
            targetLang, 
            sourceLang, 
            engine
          );
          
          console.log(`ì²­í¬ ${currentChunkIndex} ë²ˆì—­ ì‘ë‹µ ê¸¸ì´: ${result.translatedText.length}ì`);
          
          // êµ¬ë¶„ìë¡œ ì •í™•í•˜ê²Œ ë¶„í•  ì‹œë„
          if (result.translatedText.includes('\n---SUBTITLE_SEPARATOR---\n')) {
            translatedTexts = result.translatedText.split('\n---SUBTITLE_SEPARATOR---\n');
          } else if (result.translatedText.includes('---SUBTITLE_SEPARATOR---')) {
            translatedTexts = result.translatedText.split('---SUBTITLE_SEPARATOR---');
          } else {
              // êµ¬ë¶„ìê°€ ì—†ìœ¼ë©´ ê°œë³„ ë²ˆì—­ìœ¼ë¡œ ì „í™˜
              console.warn(`ì²­í¬ ${currentChunkIndex}: êµ¬ë¶„ì ì—†ìŒ - ê°œë³„ ë²ˆì—­ìœ¼ë¡œ ì „í™˜`);
            translatedTexts = [];
            for (let k = 0; k < texts.length; k++) {
                const individualResult = await translationService.translate(
                  texts[k],
                  targetLang,
                  sourceLang,
                  engine
                );
                translatedTexts.push(individualResult.translatedText);
              }
            }
            
            if (translatedTexts.length === chunk.length) {
              console.log(`âœ… êµ¬ë¶„ì ì²­í¬ ${currentChunkIndex} ë²ˆì—­ ì„±ê³µ: ${translatedTexts.length}ê°œ í…ìŠ¤íŠ¸ ì¶”ì¶œ`);
              break;
            } else {
              throw new Error(`í…ìŠ¤íŠ¸ ê°œìˆ˜ ë¶ˆì¼ì¹˜: ì˜ˆìƒ=${chunk.length}, ì‹¤ì œ=${translatedTexts.length}`);
            }
          
        } catch (translateError) {
          retryCount++;
            console.error(`ì²­í¬ ${currentChunkIndex} ë²ˆì—­ ì˜¤ë¥˜ (ì‹œë„ ${retryCount}/${validatedMaxRetries + 1}):`, translateError);
            
            if (retryCount <= validatedMaxRetries) {
              console.log(`ì²­í¬ ${currentChunkIndex} ì¬ì‹œë„ ì¤‘... (${retryCount}/${validatedMaxRetries})`);
              await new Promise(resolve => setTimeout(resolve, validatedRetryDelay));
          } else {
              // ìµœëŒ€ ì¬ì‹œë„ íšŸìˆ˜ ì´ˆê³¼ ì‹œ ê°œë³„ ë²ˆì—­ìœ¼ë¡œ ëŒ€ì²´
              console.warn(`ì²­í¬ ${currentChunkIndex}: ìµœëŒ€ ì¬ì‹œë„ ì´ˆê³¼, ê°œë³„ ë²ˆì—­ìœ¼ë¡œ ëŒ€ì²´`);
              const texts = chunk.map(entry => entry.text);
            translatedTexts = [];
            
            for (let k = 0; k < texts.length; k++) {
              try {
                const individualResult = await translationService.translate(
                  texts[k],
                  targetLang,
                  sourceLang,
                  engine
                );
                translatedTexts.push(individualResult.translatedText);
              } catch (individualError) {
                  console.error(`ê°œë³„ ë²ˆì—­ ì‹¤íŒ¨ (${k}):`, individualError);
                  if (enableFallback) {
                    const fallbackResult = await tryFallbackTranslation(texts[k], targetLang, sourceLang, engine);
                    translatedTexts.push(fallbackResult);
                  } else {
                    translatedTexts.push(`[ë²ˆì—­ì‹¤íŒ¨] ${texts[k]}`);
                  }
                }
              }
              break;
            }
          }
        }
      }

      const chunkEndTime = Date.now();
      const chunkDuration = chunkEndTime - chunkStartTime;
      console.log(`ì²­í¬ ${currentChunkIndex} ì™„ë£Œ (${chunkDuration}ms, ${Math.round(chunkChars / (chunkDuration / 1000))}ì/ì´ˆ)`);

      // ë²ˆì—­ëœ í…ìŠ¤íŠ¸ë¥¼ ê° ìë§‰ í•­ëª©ì— í• ë‹¹
      for (let j = 0; j < chunk.length; j++) {
        if (j < translatedTexts.length) {
          // ë²ˆì—­ëœ í…ìŠ¤íŠ¸ê°€ ì—¬ì „íˆ í•œêµ­ì–´ì¸ì§€ í™•ì¸
          const koreanPattern = /[ã„±-ã…|ã…-ã…£|ê°€-í£]/;
          const translatedText = translatedTexts[j].trim();
          
          if (koreanPattern.test(translatedText) && targetLang === 'en') {
            console.warn(`í•œêµ­ì–´ ê°ì§€ë¨ (${i+j}): "${translatedText.substring(0, 30)}..." - ì¬ë²ˆì—­ ì‹œë„`);
            
            // ê°œë³„ ì¬ë²ˆì—­ ì‹œë„
            try {
              const reTranslationResult = await translationService.translate(
                chunk[j].text,
                targetLang,
                sourceLang,
                engine
              );
              translatedEntries.push({
                ...chunk[j],
                text: reTranslationResult.translatedText.trim()
              });
            } catch (reTranslationError) {
              console.error(`ì¬ë²ˆì—­ ì‹¤íŒ¨ (${i+j}):`, reTranslationError);
              if (enableFallback) {
                const fallbackResult = await tryFallbackTranslation(chunk[j].text, targetLang, sourceLang, engine);
                translatedEntries.push({
                  ...chunk[j],
                  text: fallbackResult
                });
              } else {
                translatedEntries.push({
                  ...chunk[j],
                  text: `[ë²ˆì—­ì‹¤íŒ¨] ${chunk[j].text}`
                });
              }
            }
          } else {
            translatedEntries.push({
              ...chunk[j],
              text: translatedText
            });
          }
        } else {
          // ë²ˆì—­ëœ í…ìŠ¤íŠ¸ê°€ ë¶€ì¡±í•œ ê²½ìš° ì›ë³¸ ìœ ì§€
          console.warn(`ë²ˆì—­ í…ìŠ¤íŠ¸ ë¶€ì¡± (${i+j}): ì›ë³¸ ìœ ì§€`);
          translatedEntries.push(chunk[j]);
        }
      }

      totalProcessed += chunk.length;
      totalProcessedChars += chunkChars;
      
      // ì§„í–‰ë¥  ë° ì„±ëŠ¥ í†µê³„ ê³„ì‚°
      const progressPercent = Math.round((totalProcessed / entries.length) * 100);
      const elapsedTime = Date.now() - startTime;
      const averageCharsPerSecond = Math.round(totalProcessedChars / (elapsedTime / 1000));
      const remainingChars = totalCharacters - totalProcessedChars;
      const estimatedTimeRemaining = averageCharsPerSecond > 0 ? Math.round(remainingChars / averageCharsPerSecond) : 0;
      
      // ì§„í–‰ ìƒíƒœ ì—…ë°ì´íŠ¸
      translationProgress[fileId] = {
        ...translationProgress[fileId],
        progress: progressPercent,
        processedEntries: totalProcessed,
        processedCharacters: totalProcessedChars,
        averageCharsPerSecond: averageCharsPerSecond,
        estimatedTimeRemaining: estimatedTimeRemaining,
        message: `ì§„í–‰ë¥ : ${progressPercent}% (${totalProcessed}/${entries.length}ê°œ) - í‰ê·  ${averageCharsPerSecond}ì/ì´ˆ`
      };
      
      console.log(`ë²ˆì—­ ì§„í–‰ë¥ : ${totalProcessed}/${entries.length} (${progressPercent}%) - ${averageCharsPerSecond}ì/ì´ˆ, ì˜ˆìƒ ë‚¨ì€ ì‹œê°„: ${estimatedTimeRemaining}ì´ˆ`);

      // ì§„í–‰ ìƒíƒœ ì—…ë°ì´íŠ¸
      translationProgress[fileId].currentChunk = currentChunkIndex;
      translationProgress[fileId].message = `ì²­í¬ ${currentChunkIndex}/${totalChunks} ë²ˆì—­ ì¤‘... (${chunk.length}ê°œ ìë§‰, ${chunkChars}ì)`;

      try {
        if (shouldUseSrtDirect) {
          // ğŸ¯ SRT ì²­í¬ ì§ì ‘ ë²ˆì—­
          const srtChunk = SubtitleParser.generateSubtitle(chunk, 'srt');
          console.log(`ğŸ†• SRT ì²­í¬ ${currentChunkIndex}/${totalChunks} ì§ì ‘ ë²ˆì—­ ì‹œì‘ (${chunk.length}ê°œ ìë§‰, ${srtChunk.length}ì)`);
          console.log(`SRT ì²­í¬ ë¯¸ë¦¬ë³´ê¸°: ${srtChunk.substring(0, 200)}...`);
        
        let result;
          let translatedTexts = [];
        let retryCount = 0;
        
          // ì¬ì‹œë„ ë¡œì§ìœ¼ë¡œ ì•ˆì •ì„± ê°•í™”
          while (retryCount <= validatedMaxRetries) {
            try {
              // SRT ì²­í¬ ì§ì ‘ ë²ˆì—­
              result = await translationService.translate(
                srtChunk, 
                targetLang, 
                sourceLang, 
                engine
              );
              
              console.log(`ì²­í¬ ${currentChunkIndex} ë²ˆì—­ ì‘ë‹µ ê¸¸ì´: ${result.translatedText.length}ì`);
              console.log(`ì²­í¬ ${currentChunkIndex} ë²ˆì—­ ì‘ë‹µ ë¯¸ë¦¬ë³´ê¸°: ${result.translatedText.substring(0, 300)}...`);
              
              // ë²ˆì—­ëœ SRTì—ì„œ í…ìŠ¤íŠ¸ë§Œ ì¶”ì¶œ
              const translatedSrtLines = result.translatedText.split('\n');
              translatedTexts = [];
              
              for (let lineIndex = 0; lineIndex < translatedSrtLines.length; lineIndex++) {
                const line = translatedSrtLines[lineIndex].trim();
                
                // ìˆ«ì ë¼ì¸ì´ë©´ ë‹¤ìŒì´ íƒ€ì„ìŠ¤íƒ¬í”„, ê·¸ ë‹¤ìŒì´ í…ìŠ¤íŠ¸
                if (/^\d+$/.test(line)) {
                  // íƒ€ì„ìŠ¤íƒ¬í”„ ë¼ì¸ ê±´ë„ˆë›°ê¸°
                  lineIndex++;
                  if (lineIndex < translatedSrtLines.length && translatedSrtLines[lineIndex].includes('-->')) {
                    lineIndex++;
                    // í…ìŠ¤íŠ¸ ë¼ì¸(ë“¤) ìˆ˜ì§‘
                    let textLines = [];
                    while (lineIndex < translatedSrtLines.length && 
                           translatedSrtLines[lineIndex].trim() !== '' && 
                           !/^\d+$/.test(translatedSrtLines[lineIndex].trim())) {
                      textLines.push(translatedSrtLines[lineIndex].trim());
                      lineIndex++;
                    }
                    if (textLines.length > 0) {
                      translatedTexts.push(textLines.join('\n'));
                    }
                    lineIndex--; // for ë£¨í”„ì—ì„œ ì¦ê°€í•˜ë¯€ë¡œ í•˜ë‚˜ ë¹¼ê¸°
                  }
                }
              }
              
              // ì¶”ì¶œëœ í…ìŠ¤íŠ¸ ê°œìˆ˜ í™•ì¸
              if (translatedTexts.length === chunk.length) {
                console.log(`âœ… SRT ì²­í¬ ${currentChunkIndex} ì§ì ‘ ë²ˆì—­ ì„±ê³µ: ${translatedTexts.length}ê°œ í…ìŠ¤íŠ¸ ì¶”ì¶œ`);
                break; // ì„±ê³µí•˜ë©´ ë£¨í”„ íƒˆì¶œ
              } else {
                throw new Error(`í…ìŠ¤íŠ¸ ê°œìˆ˜ ë¶ˆì¼ì¹˜: ì˜ˆìƒ=${chunk.length}, ì‹¤ì œ=${translatedTexts.length}`);
              }
              
            } catch (translateError) {
              retryCount++;
              console.error(`ì²­í¬ ${currentChunkIndex} ë²ˆì—­ ì˜¤ë¥˜ (ì‹œë„ ${retryCount}/${validatedMaxRetries + 1}):`, translateError);
              
              if (retryCount <= validatedMaxRetries) {
                console.log(`ì²­í¬ ${currentChunkIndex} ì¬ì‹œë„ ì¤‘... (${retryCount}/${validatedMaxRetries})`);
                await new Promise(resolve => setTimeout(resolve, validatedRetryDelay));
              } else {
                // ìµœëŒ€ ì¬ì‹œë„ ì´ˆê³¼ ì‹œ êµ¬ë¶„ì ë°©ì‹ìœ¼ë¡œ ëŒ€ì²´ ë˜ëŠ” ê°œë³„ ë²ˆì—­
                console.warn(`ì²­í¬ ${currentChunkIndex}: ìµœëŒ€ ì¬ì‹œë„ ì´ˆê³¼, êµ¬ë¶„ì ë°©ì‹ìœ¼ë¡œ ëŒ€ì²´`);
                shouldUseSeparator = true;
                break;
              }
            }
          }
        }
      }
      
      if (shouldUseSeparator || !shouldUseSrtDirect) {
        // ğŸ”„ êµ¬ë¶„ì ë°©ì‹ ë²ˆì—­
        const texts = chunk.map(entry => entry.text);
        const combinedText = texts.join('\n---SUBTITLE_SEPARATOR---\n');
        
        console.log(`ğŸ”„ êµ¬ë¶„ì ì²­í¬ ${currentChunkIndex}/${totalChunks} ë²ˆì—­ ì‹œì‘ (${chunk.length}ê°œ ìë§‰, ${combinedText.length}ì)`);
        
        let result;
        let translatedTexts = [];
        let retryCount = 0;
        
        while (retryCount <= validatedMaxRetries) {
        try {
          result = await translationService.translate(
            combinedText, 
            targetLang, 
            sourceLang, 
            engine
          );
          
          console.log(`ì²­í¬ ${currentChunkIndex} ë²ˆì—­ ì‘ë‹µ ê¸¸ì´: ${result.translatedText.length}ì`);
          
          // êµ¬ë¶„ìë¡œ ì •í™•í•˜ê²Œ ë¶„í•  ì‹œë„
          if (result.translatedText.includes('\n---SUBTITLE_SEPARATOR---\n')) {
            translatedTexts = result.translatedText.split('\n---SUBTITLE_SEPARATOR---\n');
          } else if (result.translatedText.includes('---SUBTITLE_SEPARATOR---')) {
            translatedTexts = result.translatedText.split('---SUBTITLE_SEPARATOR---');
          } else {
              // êµ¬ë¶„ìê°€ ì—†ìœ¼ë©´ ê°œë³„ ë²ˆì—­ìœ¼ë¡œ ì „í™˜
              console.warn(`ì²­í¬ ${currentChunkIndex}: êµ¬ë¶„ì ì—†ìŒ - ê°œë³„ ë²ˆì—­ìœ¼ë¡œ ì „í™˜`);
            translatedTexts = [];
            for (let k = 0; k < texts.length; k++) {
                const individualResult = await translationService.translate(
                  texts[k],
                  targetLang,
                  sourceLang,
                  engine
                );
                translatedTexts.push(individualResult.translatedText);
              }
            }
            
            if (translatedTexts.length === chunk.length) {
              console.log(`âœ… êµ¬ë¶„ì ì²­í¬ ${currentChunkIndex} ë²ˆì—­ ì„±ê³µ: ${translatedTexts.length}ê°œ í…ìŠ¤íŠ¸ ì¶”ì¶œ`);
              break;
            } else {
              throw new Error(`í…ìŠ¤íŠ¸ ê°œìˆ˜ ë¶ˆì¼ì¹˜: ì˜ˆìƒ=${chunk.length}, ì‹¤ì œ=${translatedTexts.length}`);
            }
          
        } catch (translateError) {
          retryCount++;
            console.error(`ì²­í¬ ${currentChunkIndex} ë²ˆì—­ ì˜¤ë¥˜ (ì‹œë„ ${retryCount}/${validatedMaxRetries + 1}):`, translateError);
            
            if (retryCount <= validatedMaxRetries) {
              console.log(`ì²­í¬ ${currentChunkIndex} ì¬ì‹œë„ ì¤‘... (${retryCount}/${validatedMaxRetries})`);
              await new Promise(resolve => setTimeout(resolve, validatedRetryDelay));
          } else {
              // ìµœëŒ€ ì¬ì‹œë„ íšŸìˆ˜ ì´ˆê³¼ ì‹œ ê°œë³„ ë²ˆì—­ìœ¼ë¡œ ëŒ€ì²´
              console.warn(`ì²­í¬ ${currentChunkIndex}: ìµœëŒ€ ì¬ì‹œë„ ì´ˆê³¼, ê°œë³„ ë²ˆì—­ìœ¼ë¡œ ëŒ€ì²´`);
              const texts = chunk.map(entry => entry.text);
            translatedTexts = [];
            
            for (let k = 0; k < texts.length; k++) {
              try {
                const individualResult = await translationService.translate(
                  texts[k],
                  targetLang,
                  sourceLang,
                  engine
                );
                translatedTexts.push(individualResult.translatedText);
              } catch (individualError) {
                  console.error(`ê°œë³„ ë²ˆì—­ ì‹¤íŒ¨ (${k}):`, individualError);
                  if (enableFallback) {
                    const fallbackResult = await tryFallbackTranslation(texts[k], targetLang, sourceLang, engine);
                    translatedTexts.push(fallbackResult);
                  } else {
                    translatedTexts.push(`[ë²ˆì—­ì‹¤íŒ¨] ${texts[k]}`);
                  }
                }
              }
              break;
            }
          }
        }
      }

      const chunkEndTime = Date.now();
      const chunkDuration = chunkEndTime - chunkStartTime;
      console.log(`ì²­í¬ ${currentChunkIndex} ì™„ë£Œ (${chunkDuration}ms, ${Math.round(chunkChars / (chunkDuration / 1000))}ì/ì´ˆ)`);

      // ë²ˆì—­ëœ í…ìŠ¤íŠ¸ë¥¼ ê° ìë§‰ í•­ëª©ì— í• ë‹¹
      for (let j = 0; j < chunk.length; j++) {
        if (j < translatedTexts.length) {
          // ë²ˆì—­ëœ í…ìŠ¤íŠ¸ê°€ ì—¬ì „íˆ í•œêµ­ì–´ì¸ì§€ í™•ì¸
          const koreanPattern = /[ã„±-ã…|ã…-ã…£|ê°€-í£]/;
          const translatedText = translatedTexts[j].trim();
          
          if (koreanPattern.test(translatedText) && targetLang === 'en') {
            console.warn(`í•œêµ­ì–´ ê°ì§€ë¨ (${i+j}): "${translatedText.substring(0, 30)}..." - ì¬ë²ˆì—­ ì‹œë„`);
            
            // ê°œë³„ ì¬ë²ˆì—­ ì‹œë„
            try {
              const reTranslationResult = await translationService.translate(
                chunk[j].text,
                targetLang,
                sourceLang,
                engine
              );
              translatedEntries.push({
                ...chunk[j],
                text: reTranslationResult.translatedText.trim()
              });
            } catch (reTranslationError) {
              console.error(`ì¬ë²ˆì—­ ì‹¤íŒ¨ (${i+j}):`, reTranslationError);
              if (enableFallback) {
                const fallbackResult = await tryFallbackTranslation(chunk[j].text, targetLang, sourceLang, engine);
                translatedEntries.push({
                  ...chunk[j],
                  text: fallbackResult
                });
              } else {
                translatedEntries.push({
                  ...chunk[j],
                  text: `[ë²ˆì—­ì‹¤íŒ¨] ${chunk[j].text}`
                });
              }
            }
          } else {
            translatedEntries.push({
              ...chunk[j],
              text: translatedText
            });
          }
        } else {
          // ë²ˆì—­ëœ í…ìŠ¤íŠ¸ê°€ ë¶€ì¡±í•œ ê²½ìš° ì›ë³¸ ìœ ì§€
          console.warn(`ë²ˆì—­ í…ìŠ¤íŠ¸ ë¶€ì¡± (${i+j}): ì›ë³¸ ìœ ì§€`);
          translatedEntries.push(chunk[j]);
        }
      }

      totalProcessed += chunk.length;
      totalProcessedChars += chunkChars;
      
      // ì§„í–‰ë¥  ë° ì„±ëŠ¥ í†µê³„ ê³„ì‚°
      const progressPercent = Math.round((totalProcessed / entries.length) * 100);
      const elapsedTime = Date.now() - startTime;
      const averageCharsPerSecond = Math.round(totalProcessedChars / (elapsedTime / 1000));
      const remainingChars = totalCharacters - totalProcessedChars;
      const estimatedTimeRemaining = averageCharsPerSecond > 0 ? Math.round(remainingChars / averageCharsPerSecond) : 0;
      
      // ì§„í–‰ ìƒíƒœ ì—…ë°ì´íŠ¸
      translationProgress[fileId] = {
        ...translationProgress[fileId],
        progress: progressPercent,
        processedEntries: totalProcessed,
        processedCharacters: totalProcessedChars,
        averageCharsPerSecond: averageCharsPerSecond,
        estimatedTimeRemaining: estimatedTimeRemaining,
        message: `ì§„í–‰ë¥ : ${progressPercent}% (${totalProcessed}/${entries.length}ê°œ) - í‰ê·  ${averageCharsPerSecond}ì/ì´ˆ`
      };
      
      console.log(`ë²ˆì—­ ì§„í–‰ë¥ : ${totalProcessed}/${entries.length} (${progressPercent}%) - ${averageCharsPerSecond}ì/ì´ˆ, ì˜ˆìƒ ë‚¨ì€ ì‹œê°„: ${estimatedTimeRemaining}ì´ˆ`);

    } catch (error) {
      console.error(`ì²­í¬ ë²ˆì—­ ì „ì²´ ì‹¤íŒ¨ (${i}-${i+maxChunkSize}):`, error);
      
      // ë²ˆì—­ ì‹¤íŒ¨ì‹œ ì›ë³¸ í…ìŠ¤íŠ¸ ìœ ì§€
      for (const entry of chunk) {
        translatedEntries.push({
          ...entry,
          originalText: entry.text
        });
      }
      totalProcessed += chunk.length;
      totalProcessedChars += chunkChars;

      // ì§„í–‰ ìƒíƒœ ì—…ë°ì´íŠ¸ (ì˜¤ë¥˜ ë°˜ì˜)
      const progressPercent = Math.round((totalProcessed / entries.length) * 100);
      translationProgress[fileId].progress = progressPercent;
      translationProgress[fileId].processedEntries = totalProcessed;
      translationProgress[fileId].processedCharacters = totalProcessedChars;
      translationProgress[fileId].message = `ì²­í¬ ${currentChunkIndex} ì „ì²´ ì‹¤íŒ¨ - ì›ë³¸ í…ìŠ¤íŠ¸ ìœ ì§€`;
    }

    // API í˜¸ì¶œ ê°„ ì§§ì€ ì§€ì—° (rate limit ë°©ì§€)
    if (i + maxChunkSize < entries.length) {
      await new Promise(resolve => setTimeout(resolve, 200)); // 200ms ëŒ€ê¸°
    }
  }

  const totalTime = Date.now() - startTime;
  const finalCharsPerSecond = Math.round(totalCharacters / (totalTime / 1000));

  // ì§„í–‰ ìƒíƒœë¥¼ ì™„ë£Œë¡œ ì—…ë°ì´íŠ¸
  translationProgress[fileId] = {
    ...translationProgress[fileId],
    status: 'completed',
    progress: 100,
    processedEntries: entries.length,
    processedCharacters: totalCharacters,
    totalTime: totalTime,
    averageCharsPerSecond: finalCharsPerSecond,
    message: 'ë²ˆì—­ ì™„ë£Œ'
  };

  // ì¶œë ¥ í˜•ì‹ ê²°ì • (ì…ë ¥ í˜•ì‹ê³¼ ë™ì¼í•˜ê²Œ ë˜ëŠ” ì§€ì •ëœ í˜•ì‹)
  const finalOutputFormat = outputFormat || parsed.format;
  
  // ë²ˆì—­ëœ ìë§‰ íŒŒì¼ ìƒì„±
  const translatedContent = SubtitleParser.generateSubtitle(
    translatedEntries, 
    finalOutputFormat,
    { title: `Translated to ${targetLang}` }
  );

  // ì›ë³¸ íŒŒì¼ëª…ì—ì„œ í™•ì¥ìë¥¼ ì œê±°í•˜ê³  ë²ˆì—­ ì •ë³´ ì¶”ê°€
  const nameWithoutExt = path.parse(originalName).name;
  const outputFileName = `${nameWithoutExt}_translated_${targetLang}_${Date.now()}.${finalOutputFormat}`;
  const outputPath = path.join(__dirname, '../uploads', outputFileName);
  fs.writeFileSync(outputPath, translatedContent, 'utf8');

  // ë²ˆì—­ëœ íŒŒì¼ì˜ ë©”íƒ€ ì •ë³´ ì €ì¥
  const translatedMetaPath = path.join(__dirname, '../uploads', outputFileName + '.meta');
  const translatedMetaData = {
    originalName: `${nameWithoutExt}_translated_${targetLang}.${finalOutputFormat}`,
    sourceFile: originalName,
    translationEngine: engine,
    targetLang: targetLang,
    timestamp: new Date().toISOString(),
    translationStats: {
      totalTime: totalTime,
      totalCharacters: totalCharacters,
      averageCharsPerSecond: finalCharsPerSecond,
      totalEntries: entries.length
    }
  };
  fs.writeFileSync(translatedMetaPath, JSON.stringify(translatedMetaData), 'utf8');

  // í†µê³„ ì •ë³´
  const stats = SubtitleParser.getSubtitleStats(translatedEntries);

  res.json({
    success: true,
    data: {
      originalFileId: fileId,
      translatedFileId: outputFileName,
      originalFormat: parsed.format,
      outputFormat: finalOutputFormat,
      stats: stats,
      translationEngine: engine,
      sourceLang: sourceLang || 'auto',
      targetLang: targetLang,
      totalEntries: translatedEntries.length,
      translationOptions: {
        chunkSize: validatedChunkSize,
        translationMode: validatedTranslationMode,
        maxRetries: validatedMaxRetries,
        retryDelay: validatedRetryDelay,
        enableFallback: enableFallback
      },
      translationStats: {
        totalTime: totalTime,
        totalTimeFormatted: `${Math.floor(totalTime / 60000)}ë¶„ ${Math.floor((totalTime % 60000) / 1000)}ì´ˆ`,
        totalCharacters: totalCharacters,
        averageCharsPerSecond: finalCharsPerSecond,
        efficiency: `${finalCharsPerSecond}ì/ì´ˆ`
      },
      preview: translatedEntries.slice(0, 3), // ì²˜ìŒ 3ê°œ ì—”íŠ¸ë¦¬ ë¯¸ë¦¬ë³´ê¸°
      downloadUrl: `/translation-api/subtitle/download/${outputFileName}`,
      timestamp: new Date().toISOString()
    }
  });

  // 24ì‹œê°„ í›„ ì§„í–‰ ìƒíƒœ ì •ë³´ ì‚­ì œ
  setTimeout(() => {
    delete translationProgress[fileId];
  }, 86400000); // 24ì‹œê°„

  // ì›ë³¸ íŒŒì¼ ì‚­ì œ (ì„ íƒì‚¬í•­)
  // fs.unlinkSync(filePath);

} catch (error) {
  console.error('ìë§‰ ë²ˆì—­ ì˜¤ë¥˜:', error);
  
  // ì˜¤ë¥˜ ë°œìƒì‹œ ì§„í–‰ ìƒíƒœ ì—…ë°ì´íŠ¸
  if (translationProgress[req.body.fileId]) {
    translationProgress[req.body.fileId].status = 'error';
    translationProgress[req.body.fileId].message = error.message;
  }
  
  res.status(500).json({
    success: false,
    error: error.message || 'ìë§‰ ë²ˆì—­ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.'
  });
}
});

// ë²ˆì—­ëœ íŒŒì¼ ë‹¤ìš´ë¡œë“œ
router.get('/download/:fileId', (req, res) => {
  try {
    const fileId = req.params.fileId;
    const filePath = path.join(__dirname, '../uploads', fileId);

    if (!fs.existsSync(filePath)) {
      return res.status(404).json({
        success: false,
        error: 'íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.'
      });
    }

    const ext = path.extname(fileId);
    const mimeTypes = {
      '.srt': 'text/plain',
      '.smi': 'text/plain',
      '.vtt': 'text/vtt'
    };

    res.setHeader('Content-Type', mimeTypes[ext] || 'text/plain');
    res.setHeader('Content-Disposition', `attachment; filename="${fileId}"`);
    
    const fileStream = fs.createReadStream(filePath);
    fileStream.pipe(res);

    // ë‹¤ìš´ë¡œë“œ í›„ íŒŒì¼ ì‚­ì œ (1ì‹œê°„ í›„)
    setTimeout(() => {
      if (fs.existsSync(filePath)) {
        fs.unlinkSync(filePath);
        console.log(`ì„ì‹œ íŒŒì¼ ì‚­ì œ: ${fileId}`);
      }
    }, 3600000); // 1ì‹œê°„

  } catch (error) {
    console.error('íŒŒì¼ ë‹¤ìš´ë¡œë“œ ì˜¤ë¥˜:', error);
    res.status(500).json({
      success: false,
      error: 'íŒŒì¼ ë‹¤ìš´ë¡œë“œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.'
    });
  }
});

// ì—…ë¡œë“œëœ íŒŒì¼ ì •ë³´ ì¡°íšŒ
router.get('/info/:fileId', (req, res) => {
  try {
    const fileId = req.params.fileId;
    const filePath = path.join(__dirname, '../uploads', fileId);

    if (!fs.existsSync(filePath)) {
      return res.status(404).json({
        success: false,
        error: 'íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.'
      });
    }

    const parsed = SubtitleParser.parseSubtitle(filePath);
    const stats = SubtitleParser.getSubtitleStats(parsed.entries);

    res.json({
      success: true,
      data: {
        fileId: fileId,
        format: parsed.format,
        stats: stats,
        entries: parsed.entries
      }
    });

  } catch (error) {
    console.error('íŒŒì¼ ì •ë³´ ì¡°íšŒ ì˜¤ë¥˜:', error);
    res.status(500).json({
      success: false,
      error: 'íŒŒì¼ ì •ë³´ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.'
    });
  }
});

// ì§€ì› í˜•ì‹ ëª©ë¡
router.get('/formats', (req, res) => {
  res.json({
    success: true,
    data: {
      supportedFormats: [
        { 
          extension: 'srt', 
          name: 'SubRip Subtitle',
          description: 'ê°€ì¥ ë„ë¦¬ ì‚¬ìš©ë˜ëŠ” ìë§‰ í˜•ì‹'
        },
        { 
          extension: 'smi', 
          name: 'SAMI Subtitle',
          description: 'ì‚¼ì„±/MSì—ì„œ ê°œë°œí•œ ìë§‰ í˜•ì‹'
        },
        { 
          extension: 'vtt', 
          name: 'WebVTT',
          description: 'ì›¹ ë¹„ë””ì˜¤ í…ìŠ¤íŠ¸ íŠ¸ë™ í˜•ì‹'
        }
      ]
    }
  });
});

// ë²ˆì—­ ì‹¤íŒ¨ ë¶€ë¶„ ì¬ë²ˆì—­
router.post('/retry-failed', async (req, res) => {
  try {
    const { fileId, targetLang, sourceLang, engine = 'gemini' } = req.body;

    if (!fileId || !targetLang) {
      return res.status(400).json({
        success: false,
        error: 'í•„ìˆ˜ ë§¤ê°œë³€ìˆ˜ê°€ ëˆ„ë½ë˜ì—ˆìŠµë‹ˆë‹¤.',
        required: ['fileId', 'targetLang']
      });
    }

    // ë²ˆì—­ëœ íŒŒì¼ ê²½ë¡œ
    const filePath = path.join(__dirname, '../uploads', fileId);
    
    if (!fs.existsSync(filePath)) {
      return res.status(404).json({
        success: false,
        error: 'íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.'
      });
    }

    console.log(`ë²ˆì—­ ì‹¤íŒ¨ ë¶€ë¶„ ì¬ë²ˆì—­ ì‹œì‘: ${fileId} â†’ ${targetLang} (${engine})`);

    // íŒŒì¼ íŒŒì‹±
    const parsed = SubtitleParser.parseSubtitle(filePath);
    const entries = parsed.entries;

    // ë²ˆì—­ ì‹¤íŒ¨ í•­ëª© ì°¾ê¸°
    const failedEntries = entries.filter(entry => 
      entry.text.includes('[ë²ˆì—­ì‹¤íŒ¨]') || 
      entry.text.includes('[ë²ˆì—­ëˆ„ë½]')
    );

    if (failedEntries.length === 0) {
      return res.json({
        success: true,
        message: 'ë²ˆì—­ ì‹¤íŒ¨ í•­ëª©ì´ ì—†ìŠµë‹ˆë‹¤.',
        data: {
          retryCount: 0,
          totalEntries: entries.length
        }
      });
    }

    console.log(`ë²ˆì—­ ì‹¤íŒ¨ í•­ëª© ${failedEntries.length}ê°œ ë°œê²¬`);

    // ì‹¤íŒ¨í•œ í•­ëª©ë“¤ì„ ì¬ë²ˆì—­
    let successCount = 0;
    let failCount = 0;

    for (let i = 0; i < failedEntries.length; i++) {
      const entry = failedEntries[i];
      
      // ì›ë³¸ í…ìŠ¤íŠ¸ ì¶”ì¶œ
      let originalText = entry.text;
      if (originalText.startsWith('[ë²ˆì—­ì‹¤íŒ¨] ')) {
        originalText = originalText.replace('[ë²ˆì—­ì‹¤íŒ¨] ', '');
      } else if (originalText.startsWith('[ë²ˆì—­ëˆ„ë½] ')) {
        originalText = originalText.replace('[ë²ˆì—­ëˆ„ë½] ', '');
      }

      console.log(`ì¬ë²ˆì—­ ì‹œë„ ${i+1}/${failedEntries.length}: "${originalText.substring(0, 50)}..."`);

      // ê°™ì€ ì—”ì§„ìœ¼ë¡œ ì¬ì‹œë„
      let retrySuccess = false;
      let retryAttempt = 0;
      const maxRetryAttempts = 5;
      
      while (!retrySuccess && retryAttempt <= maxRetryAttempts) {
        try {
          const retryResult = await translationService.translate(
            originalText,
            targetLang,
            sourceLang,
            engine
          );
          
          if (retryResult && retryResult.translatedText && retryResult.translatedText.trim()) {
            // ì¬ë²ˆì—­ ì„±ê³µ
            entry.text = retryResult.translatedText;
            successCount++;
            console.log(`ì¬ë²ˆì—­ ì„±ê³µ (ì‹œë„ ${retryAttempt+1}): "${retryResult.translatedText.substring(0, 50)}..."`);
            retrySuccess = true;
          } else {
            retryAttempt++;
            if (retryAttempt <= maxRetryAttempts) {
              console.warn(`ì¬ë²ˆì—­ ê²°ê³¼ ë¶ˆì™„ì „ (ì‹œë„ ${retryAttempt}): ë‹¤ì‹œ ì‹œë„`);
              await new Promise(resolve => setTimeout(resolve, 500 * retryAttempt));
            }
          }
        } catch (retryError) {
          retryAttempt++;
          console.error(`ì¬ë²ˆì—­ ì˜¤ë¥˜ (ì‹œë„ ${retryAttempt}):`, retryError);
          if (retryAttempt <= maxRetryAttempts) {
            console.log(`ì¬ë²ˆì—­ ì¬ì‹œë„ ì¤‘... (${retryAttempt}/${maxRetryAttempts})`);
            await new Promise(resolve => setTimeout(resolve, 1000 * retryAttempt));
          }
        }
      }
      
      if (!retrySuccess) {
        // ì¬ë²ˆì—­ ì‹¤íŒ¨
        failCount++;
        console.log(`ì¬ë²ˆì—­ ìµœì¢… ì‹¤íŒ¨: ì›ë³¸ ìœ ì§€`);
      }

      // API í˜¸ì¶œ ê°„ ì§€ì—°
      await new Promise(resolve => setTimeout(resolve, 300));
    }

    // ì¬ë²ˆì—­ëœ ë‚´ìš©ìœ¼ë¡œ íŒŒì¼ ì—…ë°ì´íŠ¸
    const updatedContent = SubtitleParser.generateSubtitle(
      entries, 
      parsed.format,
      { title: `Retried translation to ${targetLang}` }
    );

    // ìƒˆë¡œìš´ íŒŒì¼ëª… ìƒì„±
    const nameWithoutExt = path.parse(fileId).name;
    const outputFileName = `${nameWithoutExt}_retried_${Date.now()}.${path.extname(fileId).substring(1)}`;
    const outputPath = path.join(__dirname, '../uploads', outputFileName);
    fs.writeFileSync(outputPath, updatedContent, 'utf8');

    res.json({
      success: true,
      data: {
        originalFileId: fileId,
        retriedFileId: outputFileName,
        retryStats: {
          totalFailedEntries: failedEntries.length,
          successCount: successCount,
          failCount: failCount,
          successRate: Math.round((successCount / failedEntries.length) * 100)
        },
        downloadUrl: `/translation-api/subtitle/download/${outputFileName}`,
        timestamp: new Date().toISOString()
      }
    });

  } catch (error) {
    console.error('ë²ˆì—­ ì¬ì‹œë„ ì˜¤ë¥˜:', error);
    res.status(500).json({
      success: false,
      error: error.message || 'ë²ˆì—­ ì¬ì‹œë„ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.'
    });
  }
});

module.exports = router; 